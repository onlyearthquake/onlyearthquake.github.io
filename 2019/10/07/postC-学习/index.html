<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>C#学习 | 晴时雨</title><meta name="description" content="C#学习"><meta name="keywords" content="C#"><meta name="author" content="onlyearthquake"><meta name="copyright" content="onlyearthquake"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/10/07/postC-%E5%AD%A6%E4%B9%A0/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="C#学习"><meta name="twitter:description" content="C#学习"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="C#学习"><meta property="og:url" content="http://yoursite.com/2019/10/07/postC-%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="晴时雨"><meta property="og:description" content="C#学习"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="泛型与类" href="http://yoursite.com/2019/10/30/%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%B1%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script><meta name="generator" content="Hexo 5.1.1"></head><body><canvas class="fireworks"></canvas><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">晴时雨</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="https://i.loli.net/2019/10/07/Ok5SXaBQeGLVWwT.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">基本语法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">数据类型补充</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%85%83%E7%BB%84"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">元组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%95%B0%E7%BB%84"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">数组</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">预编译</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">面向对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#console"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">console</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E6%96%B9%E6%B3%95"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">引用类型与值类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">重载</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%8A%A5%E9%94%99"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">报错</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%9D%82%E7%B1%BB"><span class="toc_mobile_items-number">3.3.1.</span> <span class="toc_mobile_items-text">杂类</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc_mobile_items-number">3.3.2.</span> <span class="toc_mobile_items-text">继承</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc_mobile_items-number">3.3.3.</span> <span class="toc_mobile_items-text">事件</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc_mobile_items-number">3.3.4.</span> <span class="toc_mobile_items-text">枚举</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#C"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">C++</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#IO%E7%B1%BB"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">IO类</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc_mobile_items-number">4.1.1.</span> <span class="toc_mobile_items-text">文件输入输出</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">顺序容器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="toc_mobile_items-number">4.2.1.</span> <span class="toc_mobile_items-text">容器库概览</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc_mobile_items-number">4.2.2.</span> <span class="toc_mobile_items-text">顺序容器操作</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc_mobile_items-number">4.2.3.</span> <span class="toc_mobile_items-text">迭代器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">泛型算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">关联容器</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc_mobile_items-number">4.4.</span> <span class="toc_mobile_items-text">动态内存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc_mobile_items-number">4.5.</span> <span class="toc_mobile_items-text">类的设计</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc_mobile_items-number">4.5.1.</span> <span class="toc_mobile_items-text">拷贝控制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc_mobile_items-number">4.5.2.</span> <span class="toc_mobile_items-text">重载运算符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc_mobile_items-number">4.5.3.</span> <span class="toc_mobile_items-text">面向对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc_mobile_items-number">4.5.4.</span> <span class="toc_mobile_items-text">模板与泛型</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc_mobile_items-number">4.6.</span> <span class="toc_mobile_items-text">高级用法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#BITSET"><span class="toc_mobile_items-number">4.6.1.</span> <span class="toc_mobile_items-text">BITSET</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc_mobile_items-number">4.6.2.</span> <span class="toc_mobile_items-text">随机数</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Effective-C"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Effective C++</span></a></li></ol></div></div><div id="body-wrap"><div id="web_bg"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-number">2.</span> <span class="toc-text">预编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#console"><span class="toc-number">2.2.</span> <span class="toc-text">console</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">引用类型与值类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">3.2.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A5%E9%94%99"><span class="toc-number">3.3.</span> <span class="toc-text">报错</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">杂类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.3.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.3.3.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.3.4.</span> <span class="toc-text">枚举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C"><span class="toc-number">4.</span> <span class="toc-text">C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">IO类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">4.1.1.</span> <span class="toc-text">文件输入输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">顺序容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88"><span class="toc-number">4.2.1.</span> <span class="toc-text">容器库概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.2.</span> <span class="toc-text">顺序容器操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">4.2.3.</span> <span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">泛型算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">关联容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">4.4.</span> <span class="toc-text">动态内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.5.</span> <span class="toc-text">类的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6"><span class="toc-number">4.5.1.</span> <span class="toc-text">拷贝控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.5.2.</span> <span class="toc-text">重载运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">4.5.3.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.5.4.</span> <span class="toc-text">模板与泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">高级用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BITSET"><span class="toc-number">4.6.1.</span> <span class="toc-text">BITSET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">4.6.2.</span> <span class="toc-text">随机数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Effective-C"><span class="toc-number">5.</span> <span class="toc-text">Effective C++</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">C#学习</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-07<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-12-19</time><div class="post-meta-wordcount"></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p><strong>编译与执行</strong> C#并不直接编译为机器语言，而是需要<strong>CIL</strong>的中间托管（可增强可移植性，回收效率，安全性）</p>
<p><strong>使用框架</strong></p>
<p>常用：.NETCORE //.NET Framework //Unity</p>
<h2 id="数据类型补充"><a href="#数据类型补充" class="headerlink" title="数据类型补充"></a>数据类型补充</h2><p>字面值“源代码中的固定值”如</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="number">42</span>);</span><br><span class="line">\\数字</span><br></pre></td></tr></table></figure>
<p>有较高的精度需求可在数字后加M</p>
<p>如数字很大，可加数字下划线（7.0适用</p>
<p><strong>十六进制显示</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;42:X&#125;&quot;</span>)；</span><br></pre></td></tr></table></figure>
<p><strong>round-trip</strong>强制满足变量类型</p>
<ul>
<li><strong>字符串</strong></li>
</ul>
<p><strong>静态方法</strong><code>Format</code>,<code>Compare</code>,<code>Concat</code></p>
<p><strong>实例方法</strong><code>Startwith</code>,<code>Endwith</code>,<code>Trim</code>,<code>Repalce</code>,<code>ToUpper</code></p>
<p>使用<strong>@</strong>字符可抑制转义序列</p>
<p>C#<strong>不会自动连接</strong>字符串</p>
<p><strong>字符串插值</strong> 不使用{0}占位，{name}即可，在字符串前加<strong>$</strong></p>
<p><strong>StringBuilder</strong>会改变原值的String，可使用<code>Insert</code>,<code>Append</code>,<code>Replace</code>等方法</p>
<ul>
<li><strong>数据类型转换</strong></li>
</ul>
<p><strong>显式</strong>（强制转换</p>
<p><strong>隐式</strong>（如 <code>Int</code> 到 <code>long</code> )</p>
<p>字符串到数据值<code>Parse()</code>&emsp;&emsp;<code>TryParse()</code>类似，只是转换失败会返回false,传出加out</p>
<p>Convert少量类型的直接转换（指整数，浮点数，字符串，Datetime</p>
<p><strong>区别</strong>：值类型拷贝值创建新内存；引用类型传递位置</p>
<p>引用类型：string,自定义类，地址传递（数组等</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>封装数据的轻量级方案</p>
<p>1.多个元素，一一赋值,声明可提前也可在元组中执行</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">string</span> conutry,<span class="keyword">int</span> population,<span class="keyword">double</span> area)=(China,<span class="number">14</span>,<span class="number">960.4</span>);</span><br></pre></td></tr></table></figure>
<p> 2.变量均为var，放在括号外</p>
<p>3.给元组赋顶名，可在括号后 ,或类似变量，用var声明</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">string</span><span class="number">.4</span> conutry,<span class="keyword">int</span> population,<span class="keyword">double</span> area)China=(China,<span class="number">14</span>,<span class="number">960</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> China=(<span class="keyword">string</span><span class="number">.4</span> conutry:China,<span class="keyword">int</span> population:<span class="number">14</span>,<span class="keyword">double</span> area:<span class="number">960</span>)</span><br></pre></td></tr></table></figure>
<p>4.用_舍弃部分元</p>
<p>5.类似结构的用法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> China=(country,population,area);</span><br></pre></td></tr></table></figure>
<p>（已为括号中的变量赋值过</p>
<p><strong>ValueTuple</strong>中的命名只是方便查看，实际还是Item1…</p>
<p>实际是==值类型==，支持(,,)的返回语法</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><strong>声明：</strong><code>DateType [] name</code>(如果是多维数组，方框中加逗号</p>
<p><strong>赋值与实例化</strong>可在声明时赋值，或<code>name= new string[]=&#123;&#125;</code>6.0后不必再次加入数据类型</p>
<p>交错数组</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [][] name=&#123; <span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">1</span>&#125; &amp;emsp;<span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">2</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用</strong><code>BinarySearch()</code> <code>Clear()</code> <code>Sort()</code> <code>Reverse()</code> <code>Resize()</code> </p>
<p><strong>实例方法</strong><code>GetLength</code> <code>Clone</code> </p>
<p> 变长数组<strong>ArrayList</strong></p>
<p><strong>加入</strong>List.add()&emsp;<strong>删去</strong>list.Remove()</p>
<p><strong>使用</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Int32[]   values   =   (Int32[])List.ToArray(<span class="keyword">typeof</span>(Int32));</span><br></pre></td></tr></table></figure>
<p><strong>构造器</strong><code>public list()</code>数值可不加，默认是16</p>
<p><strong>方法</strong><code>Count()</code>长度 <code>Capacity()</code>最大数量&emsp;<code>ToArray</code> <code>Insert  TimeSize Contain</code>等数组方法</p>
<h1 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a><strong>预编译</strong></h1><p>指令若干</p>
<p>#define 配置版本号</p>
<p>#if&emsp;#endif（配合define码使用</p>
<p>#param+disable/store&emsp;控制报错</p>
<p>#undef取消define码</p>
<p>#region&emsp;#endregion折叠代码</p>
<p>#line指定行号</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li><strong>属性</strong>{get;set}只读：不加set或=&gt;</li>
<li><strong>方法</strong> 可在形参中直接赋值作为默认值（放在最后</li>
<li><strong>构造与析构</strong></li>
</ul>
<p>创建对象时运行构造，结束使用析构释放内存</p>
<ol>
<li><p>共同要求：与类的名称相同，无返回值，默认无参数</p>
</li>
<li><p>不同： 一般函数有默认构造，自己写会覆盖</p>
</li>
</ol>
<p>​      析构函数前有~（不构造，无析构</p>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>6.0支持加入,省去Console</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br></pre></td></tr></table></figure>
<p>输入</p>
<ul>
<li>.Write不换行</li>
<li>.WriteLine换行，可加入格式</li>
<li>.ReadKey获取下一个字符或功能键并显示于控制台</li>
</ul>
<p>输出</p>
<ul>
<li><p>.Read单个字符</p>
</li>
<li><p>.ReadLine一行数据，可换行读取</p>
</li>
<li><p>.Beep播放提示音</p>
</li>
<li><p>.Clear清除提示信息</p>
</li>
</ul>
<p>ConsoleKeyInfo 描述按下的控制台键</p>
<p><strong>属性</strong> Key获取控制台键</p>
<p>KeyChar控制台键表示的Uni字符</p>
<p>Modifiers组合键</p>
<p><strong>方法</strong> Equals（）获取值并判断是否等于当前对象</p>
<p><strong>文件模式FileMode</strong></p>
<p>Append()添加&emsp;Create()创建新文件或覆盖原文件&emsp; OpenOrCreate()有就打开无新建</p>
<p>Truncate()清除文件内容，无文件异常。</p>
<p><strong>读写模式FileAcess</strong></p>
<p>R&emsp;W&emsp;R&amp;W</p>
<p><strong>FileStream</strong></p>
<p>文件流 需要实例化（path,Mode,Acess)</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><strong>参数</strong>（类型或元组打包</p>
<p>表达式主体方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static string GetName(string first name,string last name)&#x3D;&gt;$&quot;&#123;firstname&#125;&#123;lastname&#125;&quot;</span><br></pre></td></tr></table></figure>
<h2 id="引用类型与值类型"><a href="#引用类型与值类型" class="headerlink" title="引用类型与值类型"></a>引用类型与值类型</h2><p>引用类型：别名，前改后必改&emsp;&emsp;值类型：复制，分配内存</p>
<p>所有的类都是引用类型，包括接口</p>
<p>二次引用会覆盖而不是代替</p>
<p>使用<strong>ref,out,in</strong>关键词，使函数按地址传递；不使用会按值类型传递（简单copy参数值</p>
<p>可变参数<strong>params</strong>)在最后一个参数）数组添加</p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ol>
<li>参数数量不同</li>
<li>参数类型顺序不同</li>
<li>有无ref,out参数</li>
</ol>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>try&emsp;catch&emsp;throw&emsp;finally&emsp;</p>
<p><strong>异常类型</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">FormatException()<span class="comment">//参数格式错误</span></span><br><span class="line"></span><br><span class="line">InvalidCast...()<span class="comment">//类型转换失败</span></span><br><span class="line"></span><br><span class="line">ArguementNull...()<span class="comment">//NULL参数</span></span><br><span class="line"></span><br><span class="line">NullReference...()<span class="comment">//类似，空引用</span></span><br><span class="line"></span><br><span class="line">NotImplemented...()<span class="comment">//方法实现失败</span></span><br><span class="line"></span><br><span class="line">IndexOutOfRange...()<span class="comment">//访问不存在的集合元素</span></span><br><span class="line"></span><br><span class="line">Arithmetic...()<span class="comment">//无效数学运算</span></span><br><span class="line"></span><br><span class="line">ArrayTpeMismatch...()<span class="comment">//储存错误的数组元素</span></span><br><span class="line"></span><br><span class="line">StackOver..()<span class="comment">//深递归</span></span><br><span class="line"></span><br><span class="line">Arguement...()<span class="comment">//参数错误</span></span><br><span class="line"></span><br><span class="line">...()<span class="comment">//基本异常</span></span><br></pre></td></tr></table></figure>
<p>throw一般成对出现，try中抛出错误类型，cathch中返回调用栈</p>
<h3 id="杂类"><a href="#杂类" class="headerlink" title="杂类"></a>杂类</h3><ul>
<li>结构声明struct</li>
<li>static在限制符与返回值之间</li>
<li>ToCharArray()字符串转化为字符</li>
<li>静态方法不要嵌套</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>要求：</p>
<ol>
<li>访问性相同或子更小</li>
</ol>
<p>隐藏与覆写</p>
<p><strong>隐藏</strong>：子类声明相同会覆盖基类成员</p>
<p><strong>覆写</strong>  virtual与override</p>
<p><strong>接口</strong>interface是引用类型的，和抽象abstract的相似之处：</p>
<ol>
<li>不能实例化；</li>
<li>含未实现的方法声明；</li>
<li>子类必须实现未实现的方法，抽象类是抽象方法，接口则是所有成员（不仅是方法还有成员）。<br>差别：</li>
<li>接口可多个，抽象只能一个（或任何其他类继承）从抽象类派生的类仍可实现接口。</li>
<li>抽象类当中可以存在非抽象的方法，接口不能，它的方法只是一个声明必须用public来修饰无具现的方法。</li>
<li>抽象类中的成员变量可以被不同修饰符修饰，可接口中的成员变量默认都是静态常量。</li>
<li>抽象类=&gt;抽象   接口=&gt;行为规范</li>
</ol>
<p>多接口重名方法：显式转换与隐式转换</p>
<p><strong>显式</strong> 在声明前加入接口名（两个实例</p>
<p><strong>隐式</strong> 调用时加入接口名</p>
<p><strong>委托</strong>delegate(修饰符与变量名之间</p>
<p>作用：将方法化为参数//以及缩短代码</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><strong>声明</strong> 限制符 返回类型 委托名 事件名</p>
<p><strong>监听</strong> On…()并处理空值 ——-事件名称后加?可判断是否为空</p>
<p><strong>Handler</strong><br> 关联事件创建实例，通过+=关联方法，实现具体功能</p>
<p>一般有两个参数sender（当前对象实例）和TevntArgs e(事件相关数据</p>
<p>即为sender导致事件发生，事件的内容是e</p>
<p>加&lt;&gt;表示泛型，可表示只是第二个参数有差异</p>
<p><strong>调用</strong></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>enum</strong>限制参数为某几个确定的整数值</p>
<p>方法：GetValue(TYPE)</p>
<p>GetNames(TYPE,(value))</p>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>(顺手放这里算了)</p>
<p><strong>友元函数</strong>:不属于类的成员函数，但有访问类成员的权限（当然 重载函数是不同的函数，需要分别进行修饰）</p>
<p>对于类外的名字，可以重新进行定义（除非已经使用过一次了）</p>
<p>在成员函数中使用一个名字时，其他成员函数-&gt;类作用域-&gt;类外作用域</p>
<p>委托构造函数：委托成员的构造函数执行</p>
<p><strong>unio类：</strong>所有成员都是public的、没有定义初始构造函数、没有类内初始值、没有基类和抽象函数</p>
<p><strong>字面值常量类：</strong>数据成员都必须是字面值常量、类必须至少含有一个constexpr构造函数（一般是空的）、如果一个数据成员有初始值，那一定是一个常量表达式、析构函数必须使用默认定义</p>
<p><strong>静态数据成员：</strong>可以是不完全类型（可以是它所属的类型）；可使用静态成员作为默认实参</p>
<h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><p>ifstream和istringstream都继承自istream</p>
<p>IO对象不能进行拷贝和赋值</p>
<p>条件状态</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">strm::iostate	提供表达条件状态的完整功能</span><br><span class="line">strm::badbit	流的崩溃</span><br><span class="line">strm::fallbit 指出IO操作失败</span><br><span class="line">strm::eofbit 流到了文件的结束</span><br><span class="line">strm::goodhabit  正常状态</span><br><span class="line">s.eof()</span><br><span class="line">s.badbit()</span><br><span class="line">s.fallbit()</span><br><span class="line">s.clear()</span><br><span class="line">s.rdstate()</span><br><span class="line">s.setstate(flags)</span><br></pre></td></tr></table></figure>
<p>缓冲刷新</p>
<ul>
<li>程序结束；缓冲区满</li>
<li>操作符（endl）显式刷新</li>
<li>unitbuf设置内部状态（每次输出操作后都刷新缓冲区 无缓冲）</li>
<li>关联到另一个流( cin.tie(&amp;cout) )</li>
</ul>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>fstream ostream</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s,mode)</span></span></span><br><span class="line">fstrm.open(s)</span><br><span class="line">fstrm.close()</span><br></pre></td></tr></table></figure>
<p>定义一个空文件流对象，随后可以调用open来将它与文件关联起来</p>
<p>文件模式</p>
<p>in    out（使用out模式打开文件会丢弃已有数据 除非同时指定app模式）</p>
<p>app写操作均定位到文件末尾  ate打开文件后立即定位到文件末尾</p>
<p>trunc截断文件 binary以二进制方式进行IO</p>
<p><strong>string流</strong></p>
<p>stream strm(s);</p>
<p>strm.str();        strm.str(s);</p>
<p>istringstream 处理行内的单个单词</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> line , word;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>.line))&#123;</span><br><span class="line">	PersonInfo info;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>;</span><br><span class="line">    record &gt;&gt; info,name;</span><br><span class="line">    <span class="keyword">while</span>(record &gt;&gt; word)</span><br><span class="line">        info.phones.push_back(word);</span><br><span class="line">    pepole.push_back(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ostringstream</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;entry : people)&#123;</span><br><span class="line">	<span class="built_in">ostringstream</span> formatted ,badNums;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;nums:entry.phones)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!valid(nums))&#123;</span><br><span class="line">			badNums &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;nums;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt;format(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(badNums.str().empty())</span><br><span class="line">        os&lt;&lt; entry.name &lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">        	&lt;&lt; formatted.str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;input error:&quot;</span>&lt;&lt;entry.name</span><br><span class="line">			&lt;&lt;<span class="string">&quot;invalid number(s) &quot;</span>&lt;&lt;badNums.str()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>vector    deque</p>
<p>list    forward_list    array    string</p>
<p>选择容器的基本原则</p>
<ul>
<li>除非你有别的理由，否则使用vector</li>
<li>如果元素较小，且不接受空间的额外开销，不使用list和forward_list</li>
<li>要求随机访问，用vector或arry</li>
<li>容器中间插入删除，vector或forward_list</li>
<li>容器头尾插入删除，deque</li>
</ul>
<h3 id="容器库概览"><a href="#容器库概览" class="headerlink" title="容器库概览"></a>容器库概览</h3><p><strong>保存元素的限制</strong></p>
<p>顺序容器几乎可以保存任意类型的元素，但比如使用带有容器大小参数的初始化器，且原类型没有默认构造函数时，必须提供一个元素初始化器</p>
<p><strong>通用容器操作</strong></p>
<p>iterator  迭代器    const_iterator    只读</p>
<p>difference_type 单个元素的大小</p>
<p>value_type    元素类型</p>
<p>reference    元素左值类型（value_type&amp;）</p>
<p>C c    默认构造函数，构造空容器</p>
<p>C c1(c2)    构造c2的拷贝c1</p>
<p>C c(b,e)    构造c,将迭代器b和e指定的范围内的元素拷贝到c中</p>
<p><strong>赋值与交换</strong></p>
<p>c1=c2；c1={…}</p>
<p>a.swap(b)    swap(a,b)</p>
<p><strong>大小</strong>    c.size()    c.max_size()    c.empty()</p>
<p><strong>添加/删除</strong></p>
<p>c.insert(args)        c.erase(args)</p>
<p>c.emplace(inits)    c.clear()</p>
<p>获取迭代器</p>
<p>c.begin()    c.end()</p>
<p>c.cbegin()    c.cend()</p>
<p>迭代器范围为左闭合区间，即[begin , end),可使用递增、递减运算符（forward_list不支持递减运算符）</p>
<p>为了使用迭代器等，必须显式使用类名</p>
<p>赋值相关运算会导致左值容器内壁的迭代器、引用和指针失效</p>
<p>使用assign,将右值的元素拷贝到左值中去，类型可以不同（仅顺序容器）</p>
<h3 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h3><p><strong>添加元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.push_back(e)</span><br><span class="line">c.emplace_back(args)</span><br><span class="line">c.push_front(t)</span><br><span class="line">c.emplace_front(args)</span><br><span class="line">c.insert(p,e)<span class="comment">//返回新添加元素的迭代器</span></span><br><span class="line">c.emplace(p,args)</span><br><span class="line">c,insert(p,n,t)	<span class="comment">//插入n个值为t的元素</span></span><br><span class="line">c.insert(p.<span class="built_in">list</span>)	<span class="comment">//插入元素列表</span></span><br></pre></td></tr></table></figure>
<p>当我们用一个对象来初始化容器，或将一个对象插入到容器中时，<strong>实际放入到容器中的是对象值的拷贝，而不是对象本身</strong></p>
<p>调用emplace时，将参数传递给元素类的构造函数。</p>
<p><strong>访问元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.back()</span><br><span class="line">c.front()</span><br><span class="line">c[n]</span><br><span class="line">c.at(n)<span class="comment">//下标越界会抛出错误</span></span><br><span class="line"><span class="comment">//返回的均为引用</span></span><br></pre></td></tr></table></figure>
<p><strong>删除元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.pop_back()</span><br><span class="line">c.pop_front()</span><br><span class="line">c.erase(p)		<span class="comment">//单个迭代器</span></span><br><span class="line">c.erase(b,e)	<span class="comment">//一对迭代器指定删除范围</span></span><br><span class="line">c.clear()</span><br></pre></td></tr></table></figure>
<p><strong>改变容器大小</strong>    c.resize(n)</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>输入迭代器<ul>
<li>比较、前置后置递增运算、解引用、箭头</li>
</ul>
</li>
<li>输出迭代器<ul>
<li>递增、解引用</li>
</ul>
</li>
<li>前向迭代器、双向迭代器、随机访问迭代器</li>
</ul>
<p><strong>算法形参模式</strong></p>
<p>alg(beg , end , other args)</p>
<p>alg(beg , end , dest , other args)</p>
<p>alg(beg , end , beg2 ,other args)</p>
<p>lag(beg , end , beg2 , end2, other args)</p>
<p><strong>算法命名规范</strong></p>
<ul>
<li>重载传递谓词（个数上不相等）</li>
<li>_if版本的算法（接受谓词参数的算法）</li>
<li>区分拷贝和不拷贝元素的版本</li>
</ul>
<h2 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h2><p>lamba</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; word,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stable_sort(word.begin(),word.end(),</span><br><span class="line">               [])(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a,<span class="keyword">const</span> <span class="built_in">string</span> &amp; b)</span><br><span class="line">    				&#123;<span class="keyword">return</span> a.size()&lt;b.size();&#125;;</span><br><span class="line">    <span class="keyword">auto</span> wc =find_if(words.begin(),words.end(),</span><br><span class="line">                    [sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)</span><br><span class="line">                     &#123;<span class="keyword">return</span> a.size() &gt;= sz&#125;);&#125;;</span><br><span class="line">	<span class="keyword">auto</span> count = words.end() - wc;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; count &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;make_plural(count,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;s&quot;</span>)</span><br><span class="line">        &lt;&lt;<span class="string">&quot; of length &quot;</span>&lt;&lt; sz &lt;&lt; <span class="string">&quot; or longer&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	for_each(wc , words.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;count &lt;&lt; s &lt;&lt;<span class="string">&quot; &quot;</span>;&#125;);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获</p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>map与Set：<br>都有相应的键，但set中没有值，也不支持下标操作</p>
<p>multimap multiset:允许有重复键</p>
<p>必须定义 比较符号（decltype(Type))</p>
<p><strong>pair类型</strong></p>
<p>pair成员是public的，可以提供初始化器，如<code>pair&lt;string , string&gt; author&#123;&quot;James&quot;,&quot;Joyce&quot;&#125;;</code></p>
<p>map在insert后会返回一个pair，该pair的first为对应迭代器，second为一个bool值，为是否成功插入进map</p>
<p>erase返回删除的元素数量，如果是一对迭代器，返回后一个迭代器</p>
<p>下标操作（建议使用at方法，会进行参数检查）</p>
<p>查找find count euqal_range</p>
<p><strong>无序容器</strong> 没有‘&gt;’等比较符号，使用哈希函数无序排列,使用类自己的==符号</p>
<p>自定义的类自定义哈希函数去）</p>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p><strong>智能指针：</strong>shared_ptr    unique_ptr</p>
<p>智能指针也有模板，可用make_shared&lt;&gt;函数创建一个</p>
<p>shared_ptr一旦变为0，就会销毁对象</p>
<p>当使用内置指针时，如果在new和delete之间发生异常且没有进行错误处理，就会发生内存泄露</p>
<p>shared_ptr默认自己指向的是动态内存，会调用delete销毁对应内存，但也可以通过传递给shared_ptr删除器来自定义删除操作的进行</p>
<p>unique_ptr拥有自己管理的对象，不支持赋值和拷贝操作，但可以通过release和reset函数将控制权转移给另一个unique_ptr</p>
<p>但重载unique_ptr删除器会影响到它的构造，因此必须在声明中显式指出</p>
<p><strong>weak_ptr</strong>弱共享指针，指向一个由shared_ptr管理的对象</p>
<p>使用lock访问管理的对象，当其不为空，执行操作</p>
<p><strong>动态数组</strong></p>
<p>int a= new int[10];</p>
<p>使用<code>delete[]</code>管理，也能使用unique_ptr管理，但不能使用shared_ptr，若想使用，必须带上自己的删除器</p>
<p><strong>allowcator</strong></p>
<p>为什么需要alloecator:分配动态数组时不一定需要所有的值，可能类没有构造函数</p>
<p><code>allowcator &lt;T&gt; a</code>定义allocator对象</p>
<p><code>a.allocate(n)</code>分配原始内存</p>
<p><code>a.deallocate(p,n)</code>释放内存（当然，在destory之后）</p>
<p><code>a.construct(p,args)</code>构造一个对象</p>
<p><code>a.destory(p)</code>正常的析构</p>
<p><code>uninitialized_copy(b,e,b2)</code></p>
<p><code>uninitial_fill(b,e,t)</code></p>
<h2 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h2><h3 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a><strong>拷贝控制</strong></h3><p>拷贝构造<code>T(const T &amp;)</code></p>
<ul>
<li>将对象作为实参传递给非引用的形参</li>
<li>从一个返回类型为非引用的函数返回对象</li>
<li>花括号初始化数组或聚合类中的成员</li>
</ul>
<p>拷贝赋值   移动构造    移动赋值  析构</p>
<p>什么时候会调用析构函数</p>
<ul>
<li>变量离开作用域</li>
<li>对象（容器）被销毁，成员也被销毁</li>
<li>对动态分配的对象应用delete</li>
<li>临时对象：创建它的完整表达式结束</li>
</ul>
<p>三/五法则：拷贝构造、赋值、析构（移动构造和移动赋值）往往同时存在</p>
<p>当然，不是所有类都能使用拷贝函数（如iostream），使用<code>= delete</code>阻止拷贝</p>
<p><strong>拷贝与资源管理</strong></p>
<p>确定拷贝的语义：</p>
<ul>
<li>像值一样，每一个对象都具有独立的数据</li>
<li>像指针一样，所有类共享底层数据</li>
</ul>
<p>类值拷贝：先拷贝，再删除（反之无法处理自赋值现象）,绝大多数赋值运算符组合了析构和拷贝函数的工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HasePtr&amp; HasPtr::p=<span class="keyword">operator</span> = (<span class="keyword">const</span> HastPtr&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = newp;</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>像指针的类</p>
<p>最好的方法：使用shared_ptr，除非我们想直接管理资源</p>
<p>则应使用引用计数：</p>
<ul>
<li>初始化时，创建引用计数</li>
<li>拷贝构造时，不分配新的计数器，而是拷贝成员，递增计数器</li>
<li><p>析构函数递减计数器，为0时释放内存</p>
</li>
<li><p>拷贝操作时，增右减左（先增后减，防止自赋值）</p>
</li>
</ul>
<h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p>输入输出不能设为成员函数</p>
<p>==和!=必须同时重载，但可以把实际任务只委托到一个函数中；应具有传递性</p>
<p><strong>关系运算</strong></p>
<p>当两个对象!=时，应该有&lt;关系</p>
<p>所有类的赋值运算都建议放在类里</p>
<p><strong>下标运算</strong></p>
<p>下标运算必须是成员函数，以访问的元素的引用为返回值，最好定义常量和变量版本</p>
<p><strong>递增运算</strong></p>
<p>check,合法后返回对应引用</p>
<p>区分前置后置：后置有额外形参int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobStr&amp; StrBlobStr::<span class="keyword">operator</span> ++()</span><br><span class="line">&#123;</span><br><span class="line">    check(val,<span class="string">&quot;the element is the end of array&quot;</span>);</span><br><span class="line">    cur++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">StrBlobStr&amp; StrBlobStr::<span class="keyword">operator</span> ++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobStr old = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标准库中的比较运算符</strong></p>
<p>模板类，定义在fuctional头文件中</p>
<p><code>plus&lt;Type&gt;</code> <code>divide&lt;Type&gt;</code></p>
<p><strong>可调用对象与function</strong></p>
<p>普通函数、lambda、类函数都能以同样的形式调用，但他们的类型不一样</p>
<p>lambda具有自己的类型，无法用bind直接管理，使用function来解决该问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; f1 = divide();</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span> , function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; &gt;biniops =&#123;</span><br><span class="line">    &#123;<span class="string">&quot;+&quot;</span>,add&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;-&quot;</span>,<span class="built_in">std</span>::minus()&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;/&quot;</span>,divide&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，这样的构造没有考虑函数重载问题</p>
<p>为了解决重载，我们储存函数指针而非函数名（当然，也可以用lambda指定我们需要的版本）</p>
<p><strong>类型转换运算符</strong></p>
<p>类型转换符是隐式执行的，无法给函数传递实参，不用指定返回值</p>
<p>但隐式转换往往会带来一些意想不到的问题（如经典的 cin &lt;&lt; 42），因此，需要显式转换的出现</p>
<p>当然，显式转换也有例外（在条件语句中使用）</p>
<p><code>explict operator int() const &#123;return 42;&#125;</code></p>
<ul>
<li>if、while、do…while、for的条件部分</li>
<li>逻辑运算符、三目运算符</li>
</ul>
<p>避免二义性：两个类型间的转换过程最好只有一个</p>
<p>类型转换+重载运算符（二义性的神）</p>
<h3 id="面向对象-1"><a href="#面向对象-1" class="headerlink" title="面向对象"></a>面向对象</h3><p>final 不希望其他类继承它</p>
<p>编译器在编译时无法确定某个特定的转换在运行时是否安全，仅能通过检查指针或引用的静态类型来推断转换是否合法</p>
<p>派生类向基类的自动类型转换只对指针或引用有效，基类向派生类不存在隐式类型转换</p>
<p>动态绑定只有当使用指针或引用调用虚函数时才会发生</p>
<p>我们可以给纯虚函数定义，但是函数体必须在类的外部</p>
<p>友元关系不能传递或继承</p>
<p>函数调用的步骤</p>
<ul>
<li>确定obj的静态类型</li>
<li>依次向基类查找函数</li>
<li>进行类型检查</li>
<li><p>根据调用的是否是虚函数产生不同的代码</p>
</li>
<li><p>名字查找快于类型检查）</p>
</li>
</ul>
<p>虚析构函数将组织移动操作的自动合成</p>
<p>容器中放置指针而非对象</p>
<h3 id="模板与泛型"><a href="#模板与泛型" class="headerlink" title="模板与泛型"></a>模板与泛型</h3><p>非类型模板参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N] , <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板非类型变量是一个常量值</p>
<p>模板在实例化时才会被编译器编译，头文件往往既包括声明也包括定义</p>
<p>模板类外声明成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i,<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= data -&gt; size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类内可省略<code>template &lt;typename T&gt;</code>的声明</p>
<p>类模板和友元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typenam T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;T&gt;;</span>	<span class="comment">//仅能访问相同实例化的Pal</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">    <span class="comment">//能访问Pal2所有实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板被使用时才会被实例化，意味着相同实例可能出现在多个文件中，需要显式实例化</p>
<p><code>extern template class Blob&lt;string&gt;</code></p>
<p><strong>类型转换与模板参数</strong></p>
<p>只有const转换与数组、函数指针转换适用</p>
<p>相同模板参数：如果两个类型不匹配就会报错，不会进行类型转换</p>
<p>Mod\<T\>::Type</p>
<p><code>remove_reference</code>当T为</p>
<ul>
<li>X&amp; 或 X&amp;&amp;             X</li>
<li>否则         T</li>
</ul>
<p><code>add_const</code></p>
<ul>
<li>X&amp;、const X或函数      T</li>
<li>否则            const T</li>
</ul>
<p><code>add_lvalue_reference</code></p>
<ul>
<li>X&amp;         T</li>
<li>X&amp;&amp;      X&amp;</li>
<li>否则      T&amp;</li>
</ul>
<p><code>add_rvalue_reference</code></p>
<ul>
<li>X&amp; 或X&amp;&amp;       T</li>
<li>否则            T&amp;&amp;</li>
</ul>
<p><code>remove_pointer</code> <code>add_pointer</code> <code>make_signed</code> <code>remove_extent</code> <code>remove_all_extents</code></p>
<p><strong>引用折叠</strong></p>
<ul>
<li>X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; 都会折叠成X&amp;</li>
<li>X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</li>
</ul>
<p>调用中使用std::forward保持类型信息</p>
<p><strong>函数重载</strong>优先使用更特例化的函数版本（非模板版本比模板好）</p>
<p><strong>可变参数模板</strong></p>
<p><code>template &lt;typename T,typenames...Args&gt;</code></p>
<p><code>void fpp(const T &amp;t,const Args&amp;.. rest)</code></p>
<p>使用sizeof…(Args)获取包中的参数数量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T&amp; t,<span class="keyword">const</span> Args...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os,rest...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">&#125;<span class="comment">//兜底 结束递归</span></span><br></pre></td></tr></table></figure>
<p>对于一个参数包，除了获取大小之外，只能扩展（如上）</p>
<p><strong>转发参数包</strong> forward\<Args\>(args..)</p>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="BITSET"><a href="#BITSET" class="headerlink" title="BITSET"></a>BITSET</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;n&gt; b;</span><br><span class="line"><span class="function"><span class="built_in">bitset</span>&lt;n&gt; <span class="title">b</span><span class="params">(u)</span></span>;</span><br><span class="line">b.any()</span><br><span class="line">b.all()</span><br><span class="line">b.none()</span><br><span class="line">b.count()</span><br><span class="line">b.size()</span><br><span class="line">    </span><br><span class="line">b.test(pos)</span><br><span class="line">b.<span class="built_in">set</span>(pos,v)</span><br><span class="line">b.<span class="built_in">set</span>()</span><br><span class="line">b.reset(pos)</span><br><span class="line">b.reset()</span><br><span class="line">b.flip(pos)</span><br><span class="line">b.flip()</span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p><code>default_random_engine</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Engine e; <span class="function">Engine <span class="title">e</span><span class="params">(s)</span></span>;</span><br><span class="line">e.seed(s);</span><br><span class="line">e.min(); e.max();</span><br><span class="line">e.discard(u);</span><br></pre></td></tr></table></figure>
<p>分布对象</p>
<p><code>uniform_int_distrubution&lt;unsigned&gt;u(0,9)</code></p>
<p>标准实数：<code>uniform_real_distribution&lt;double&gt;d(0,1)</code></p>
<p>正态分布：<code>normal_distribution&lt;&gt; n(4,1.5)</code></p>
<p>二次分布：bernoulli_distribution</p>
<h1 id="Effective-C"><a href="#Effective-C" class="headerlink" title="Effective C++"></a>Effective C++</h1><ul>
<li>virtual </li>
</ul>
<p>不继承别随便写基类（会占用空间两个ints，有可能有vptr），如果数据本身比较小，会大大增加无用空间</p>
<p>如果class本身没有virtual的析构函数，不要尝试继承它（包括所有STL容器类）</p>
<ul>
<li><p>自赋值</p>
<ul>
<li>特判</li>
<li>给暂时指针，先复制再删除（具有异常安全性）</li>
</ul>
</li>
<li><p>.智能指针</p>
</li>
</ul>
<p>使用独立语句把资源放到智能指针中</p>
<p>访问原始指针（get()）方法，如果有访问原始资源的需求，以类似方法实现（虽然不方便，但泄露可能比较小）</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">onlyearthquake</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/10/07/postC-%E5%AD%A6%E4%B9%A0/">http://yoursite.com/2019/10/07/postC-%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">晴时雨</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-full"><a href="/2019/10/30/%E6%B3%9B%E5%9E%8B%E4%B8%8E%E7%B1%BB/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>泛型与类</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/10/30/泛型与类/" title="泛型与类"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">泛型与类</div></a></div></div><div class="clear_both"></div></div></div></div><footer style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="footer"><div class="copyright">&copy;2019 - 2021 By onlyearthquake</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>